
package org.apache.nutch.analysis.unl.ta;

import org.apache.nutch.util.NutchConfiguration;
import org.apache.hadoop.conf.Configuration;

import java.util.TreeSet;
import java.util.Stack;
import java.util.Vector;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.io.*;
import org.apache.nutch.unl.UNL;


public class ADictionary
{
	static ByteMeth ByteMeth;
	static UnicodeConverter TC;
	static String x = "";
	static String y = "";
	static boolean b=true;
	// initialise dictionary
	static BTree Noun_BTree = new BTree();
	static BTree Verb_BTree = new BTree();
	static BTree Adjective_BTree = new BTree();
	static BTree Adverb_BTree = new BTree();
	static BTree Particle_BTree = new BTree();
	static BTree Neg_Finite_Verb_BTree = new BTree();
	static BTree Conjuntion_BTree = new BTree();
	static BTree Interjection_BTree = new BTree();
	static BTree Interrogative_BTree = new BTree();
	static BTree Interrogative_Adj_BTree = new BTree();
	static BTree Demo_Adj_BTree = new BTree();
	static BTree Finite_Verb_BTree = new BTree();
	static BTree Postposition_BTree = new BTree();
	static BTree Intensifier_BTree = new BTree();
	static BTree Non_Tamil_BTree = new BTree();
	static BTree m_End_Noun_BTree = new BTree();
    static BTree ProNoun_BTree = new BTree();
    static BTree En_BTree = new BTree();
	static BTree Entity_BTree = new BTree();
	
	// load dictionary in memory
	static
	{
		Configuration conf = NutchConfiguration.create();
		String path=conf.get("analyzer");
          //  String path="./src/Analyser/Analyser/";
		Verb_BTree.updateDictTree(path+"Verb_vi.txt");
		Noun_BTree.updateDictTree(path+"Noun_pe.txt");
		Adjective_BTree.updateDictTree(path+"Adjective_pe_a.txt");
		Adverb_BTree.updateDictTree(path+"Adverb_vi_a.txt");
		Particle_BTree.updateDictTree(path+"Particle_i_so.txt");
		Postposition_BTree.updateDictTree(path+"Postposition_sollurubu.txt");
		Neg_Finite_Verb_BTree.updateDictTree(path+"Neg_Finite_Verb_e_v_mu.txt");
		Conjuntion_BTree.updateDictTree(path+"Conjuction_i_i_so.txt");
		Interjection_BTree.updateDictTree(path+"Interjection_vi_i_so.txt");
		Interrogative_BTree.updateDictTree(path+"Interrogative_Noun_vi_pe.txt");
		Interrogative_Adj_BTree.updateDictTree(path+"Interrogative_Adj_vi_pe_a.txt");
		Demo_Adj_BTree.updateDictTree(path+"Demon_Adjective_su_pe_a.txt");
		Finite_Verb_BTree.updateDictTree(path+"Finite_Verb_vi_mu.txt");

		Intensifier_BTree.updateDictTree(path+"Intensifier.txt");
		Non_Tamil_BTree.updateDictTree(path+"NonTamil.txt");
		m_End_Noun_BTree.updateDictTree(path+"m_End_Noun.txt");
		ProNoun_BTree.updateDictTree(path+"pronoun.txt");
		En_BTree.updateDictTree(path+"En.txt");
		Entity_BTree.updateDictTree(path+"entitylist.txt");
		b=false;
		
	}


	/*public static void reloadDic()
	{
		////////System.out.println("Reloading Dictionary...");

		Verb_BTree.makeEmpty();
		Noun_BTree.makeEmpty();
		Adjective_BTree.makeEmpty();
		Adverb_BTree.makeEmpty();
		Particle_BTree.makeEmpty();
		Postposition_BTree.makeEmpty();
		Neg_Finite_Verb_BTree.makeEmpty();
		Conjuntion_BTree.makeEmpty();
		Interjection_BTree.makeEmpty();
		Interrogative_BTree.makeEmpty();
		Interrogative_Adj_BTree.makeEmpty();
		Demo_Adj_BTree.makeEmpty();
		Finite_Verb_BTree.makeEmpty();
		Intensifier_BTree.makeEmpty();
		Non_Tamil_BTree.makeEmpty();
		m_End_Noun_BTree.makeEmpty();
		ProNoun_BTree.makeEmpty();
		En_BTree.makeEmpty();
		Entity_BTree.makeEmpty();
		////////System.out.println("going to load the dictionary");

		Verb_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Verb_vi.txt");
		////////System.out.println("loaded");
		Noun_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Noun_pe.txt");
		////////System.out.println("loaded");
		Adjective_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Adjective_pe_a.txt");
		////////System.out.println("loaded");
		Adverb_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Adverb_vi_a.txt");
		////////System.out.println("loaded");
		Particle_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Particle_i_so.txt");
		////////System.out.println("loaded");
		Postposition_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Postposition_sollurubu.txt");
		  ////////System.out.println("loaded");
		Neg_Finite_Verb_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Neg_Finite_Verb_e_v_mu.txt");
		  ////////System.out.println("loaded");
		Conjuntion_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Conjuction_i_i_so.txt");
		////////System.out.println("loaded");
		Interjection_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Interjection_vi_i_so.txt");
		////////System.out.println("loaded");
		Interrogative_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Interrogative_Noun_vi_pe.txt");
		 // //////System.out.println("loaded");
		Interrogative_Adj_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Interrogative_Adj_vi_pe_a.txt");
		  ////////System.out.println("loaded");
		Demo_Adj_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Demon_Adjective_su_pe_a.txt");
		////////System.out.println("loaded");
		Finite_Verb_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Finite_Verb_vi_mu.txt");
		////////System.out.println("loaded");

		Intensifier_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Intensifier.txt");
		////////System.out.println("loaded");
		Non_Tamil_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/Intensifier.txt");
		////////System.out.println("loaded");
		m_End_Noun_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/m_End_Noun.txt");
		////////System.out.println("loaded");
		ProNoun_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/pronoun.txt");
		////////System.out.println("loaded");
		En_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/En.txt");
		Entity_BTree.updateDictTree("clia/unl/unicode/analyzer/Dictionary/entitylist.txt");
		////////System.out.println("loaded");
	}*/

	// dictionary checking order - wont follow any rule
	public static boolean check(Stack allStk, byte topElmt1[])
	{
	

		Stack s2 = new Stack();
		s2.push(new Entry(topElmt1, -1));
		
		Sandhi.kctp(s2);
		allStk.push(s2);
		String input="";
		String inputstring="";
		Stack s1 = (Stack) allStk.pop();
		byte[] topElmt = ((Entry) s1.peek()).getPart();
		byte[] oldTopElmt = topElmt.clone();
		//String input = TC.revert(topElmt);
		//System.out.print("here");
		for(int i=0;i<topElmt.length;i++)
		{
		//	System.out.print(topElmt[i]);
			input+=topElmt[i];
		}
		for(int i=0;i<topElmt1.length;i++)
		inputstring+=topElmt1[i];
		
		//////System.out.println("chk"+input);
		boolean found = false;
		boolean isVerb = false;
		
		 if(Entity_BTree.contains(inputstring))
		{
			Stack s = new Stack();
			s.push(new Entry(topElmt1,Tag.Entity));
			allStk.push(s);
			found = true;
			return true;
		}
		if (BooleanMethod.isPronoun(topElmt))
		{

			Stack s = (Stack) s1.clone();

			// doubt why poping?
			s.pop();
			s.push(new Entry(topElmt, Tag.Pronoun));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("2");
		if (BooleanMethod.isPronoun_Case(topElmt))
		{
		
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.PronounCase));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("3");
		if (BooleanMethod.isPronoun_Clitic(topElmt))
		{
			////////System.out.println("pronoun clitic");
			//////System.out.println( "Pronoun Clitic");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.PronounClitic));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("4");
		if (Demo_Adj_BTree.contains(input))
		{

			////////System.out.println("Demo Adj");
			//////System.out.println( "Demo Adj");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.DemonstrativeAdjective));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("5");
		 if (Neg_Finite_Verb_BTree.contains(input))
		{
			////////System.out.println("NegFiniteVerb");
			//////System.out.println( "NegFiniteVerb");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.NegativeFiniteVerb));
			allStk.push(s);
			found = true;

		}
		//////System.out.println("6");
		//////System.out.println("size of Tree"+Finite_Verb_BTree.size());
		if (Finite_Verb_BTree.contains(input))
		{
			////////System.out.println("Finite Verb");
			//////System.out.println( "Finite Verb");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.FiniteVerb));
			allStk.push(s);
			found = true;

		}
		//////System.out.println("7");
		//////System.out.println("size of stack is."+Finite_Verb_BTree.size());
		 if (Interjection_BTree.contains(input))
		{
			////////System.out.println("Interjection");
			//////System.out.println( "Interjection");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Interjection));
			allStk.push(s);
			found = true;

		}
		//////System.out.println("8");
		if (Interrogative_BTree.contains(input))
		{
			////////System.out.println("InterrogativeNoun");
			//////System.out.println( "InterrogativeNoun");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.InterrogativeNoun));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("9");
		if (Interrogative_Adj_BTree.contains(input))
		{
			////////System.out.println("InterrogativeAdj");
			//////System.out.println( "InterrogativeAdj");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.InterrogativeAdjective));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("10");
		 if (Conjuntion_BTree.contains(input))
		{
			////////System.out.println("IIS");
			//////System.out.println( "IIS");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Conjunction));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("11");
		if (Adjective_BTree.contains(input))
		{
			////////System.out.println("ADJ");
			//////System.out.println( "ADJ");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Adjective));
			allStk.push(s);
			found = true;

		}
		//////System.out.println("12");
		if (Intensifier_BTree.contains(input))
		{
			////////System.out.println("Intensifier");
			//////System.out.println( "Intensifier");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Intensifier));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("13");
		 if (Particle_BTree.contains(input))
		{
			////////System.out.println("Particle");
			//////System.out.println( "Particle");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Particle));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("14");
		 if (Postposition_BTree.contains(input))
		{
			//////System.out.println("postPosition");
			//////System.out.println( "Postposition");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Postposition));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("15");
		 if (Verb_BTree.contains(input))
		{
			////////System.out.println("verb");
			//////System.out.println( "Verb");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Verb));
			allStk.push(s);
			found = true;
			isVerb = true;
		}
		//////System.out.println("16");
		if (Adverb_BTree.contains(input))
		{
			////////System.out.println("adverb");
			//////System.out.println( "Adverb");
			Stack s = (Stack) s1.clone();

			s.pop();
			s.push(new Entry(topElmt, Tag.Adverb));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("17");
		//////System.out.println("Non_Tamil_BTree"+Non_Tamil_BTree.size());
		if(Non_Tamil_BTree.contains(inputstring))
		{
			////////System.out.println("Nn-Tamil");
			//////System.out.println( "Non Tamil");
			Stack s = new Stack();

			s.push(new Entry(topElmt1, Tag.NonTamilNoun));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("18");
		////System.out.println("noun btree"+input);
		if (Noun_BTree.contains(input))
		{
			////////System.out.println("Noun");
			//////System.out.println( "Noun");
			Stack s = (Stack) s1.clone();
			s.pop();
			s.push(new Entry(topElmt, Tag.Noun));
			allStk.push(s);
			found = true;
		}
		//////System.out.println("19");
		 if (m_End_Noun_BTree.contains(input))
				{
			//		//////System.out.println("m_End_Noun");
					//////System.out.println( "m_End_Noun");
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(topElmt,Tag.AdjectivalNoun));
					allStk.push(s);
					found = true;
		}
		//////System.out.println("20");
		 if(Entity_BTree.contains(input))
		{
					//Utils.printOut(Analyser.print, x + "Entity");
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(topElmt,Tag.Entity));
					allStk.push(s);
					found = true;
		}
		if(!found)
		{
			
		}
		//////System.out.println("Hello bharath");		
		// found for future
		if (found)
		{
			return true;
		}
		
	
		return false;
	}
	public static boolean tourismDomain(Stack allStk,byte [] topElmt1)
	{
		try
		{
		BufferedWriter bw=new BufferedWriter(new FileWriter("/root/output.txt",true));
		Stack s2 = new Stack();
		s2.push(new Entry(topElmt1, -1));
		Sandhi.kctp(s2);
		allStk.push(s2);
		Stack s1 = (Stack) allStk.pop();
		byte[] topElmt = ((Entry) s1.peek()).getPart();
		String ahcheck="";
	
		 //for making அ as ஏ  ex அங்க  becomes அங்கே
            if ((topElmt[topElmt.length - 1] == 1) && ((topElmt[topElmt.length - 2] == 14) || (topElmt[topElmt.length - 2] == 29))) {
                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 1] = 8; // 8 is internal code value of ஏ
                for (int i = 0; i < oldTopElmt.length; i++) {
                    ahcheck += oldTopElmt[i];
                }
                if (Adverb_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Adverb));
                    allStk.push(s);
                    return true;
                }
            }



            //for making அ  as ஐ  ex எத்தன becomes எத்தனை
           if (topElmt[topElmt.length - 1] == 1) {

                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 1] = 9; // 9 is internal code value of ஐ
                for (int i = 0; i < oldTopElmt.length; i++) {
                    ahcheck += oldTopElmt[i];
                }
                if (Interrogative_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.InterrogativeNoun));
                    allStk.push(s);
                    return true;
                } else if (ProNoun_BTree.contains(ahcheck)) {

                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Pronoun));
                    allStk.push(s);
                    return true;
                } else if (Noun_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Noun));
                    allStk.push(s);
                    return true;
                } else if (Neg_Finite_Verb_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.NegativeFiniteVerb));
                    allStk.push(s);
                    return true;
                } else if (Entity_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();

                    s.push(new Entry(oldTopElmt, Tag.Entity));
                    allStk.push(s);
                    return true;
                }
            }


            //adding ள்  at the end of word ex அவ become அவள்
            if ((topElmt[topElmt.length - 1] == 1) && ((topElmt[topElmt.length - 2] == 27) || (topElmt[topElmt.length - 2] == 14))) {
                int length = topElmt.length + 1;
                byte[] oldTopElmt = new byte[length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt[topElmt.length] = 29;  // 29 is internal code value of ள்
                ahcheck = "";
                for (int i = 0; i < oldTopElmt.length; i++) {
                    ahcheck += oldTopElmt[i];
                }
                if (ProNoun_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Pronoun));
                    allStk.push(s);
                    return true;
                } else if (Noun_BTree.contains(ahcheck)) {
                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Noun));
                    allStk.push(s);
                    return true;
                }

            }

            //உ rule for colloquial words
           if(ByteMeth.endsWith(topElmt, Constant.u)) {
                //bw.write(str+"\n");
                //System.out.println(UnicodeConverter.revert(topElmt).toString());
                String chk = "";
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.u.length);

                chk = "";
                for (int i = 0; i < oldTopElmt.length; i++) {
                    chk += oldTopElmt[i];
                }
                if (Verb_BTree.contains(chk)) {

                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Verb));
                    allStk.push(s);
                    return true;


                } else if (Interrogative_BTree.contains(chk)) {

                    Stack s = (Stack) s1.clone();
                    s.pop();

                    s.push(new Entry(oldTopElmt, Tag.InterrogativeNoun));
                    allStk.push(s);
                    return true;

                } else if (ProNoun_BTree.contains(chk)) {

                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Pronoun));
                    allStk.push(s);
                    return true;

                } else if (Noun_BTree.contains(chk)) {

                    Stack s = (Stack) s1.clone();
                    s.pop();
                    s.push(new Entry(oldTopElmt, Tag.Noun));
                    allStk.push(s);
                    return true;

                }
            }	
//above is mine
		// for making அ as ஆ  ex சீன becomes சீனா
		if(topElmt[topElmt.length-1]==1)
		{
			byte[] oldTopElmt = topElmt.clone();
			oldTopElmt[oldTopElmt.length-1]=2; // 2 is internal code value of ஆ
			String str=UnicodeConverter.revert(oldTopElmt);
			for(int i=0;i<oldTopElmt.length;i++)
			ahcheck+=oldTopElmt[i];
			 if(Entity_BTree.contains(ahcheck))
			{
					bw.write(str+"\n");
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(topElmt,Tag.Entity));
					allStk.push(s);
					return true;
					
			}
			
			
		}
		//System.out.println("before revert="+UnicodeConverter.revert(topElmt));
		// adding ம்  at the end of word ex மகாபல்லிபுர become மகாபல்லிபுரம்
		
		if(topElmt[topElmt.length-1]==1)
		{
			//System.out.println("ன்  adding");
			int length=topElmt.length+1;
			byte [] oldTopElmt=new byte[length];
			for(int i=0;i<topElmt.length;i++)
			{
				oldTopElmt[i]=topElmt[i];
			}
			////System.out.println("revert="+UnicodeConverter.revert(oldTopElmt));
			oldTopElmt[topElmt.length]=31; //31 is internalcode value of ன் 
			String str=UnicodeConverter.revert(oldTopElmt);
			////System.out.println("after added ன் revert="+UnicodeConverter.revert(oldTopElmt));
			ahcheck="";
			for(int i=0;i<oldTopElmt.length;i++)
			ahcheck+=oldTopElmt[i];
			 if(Entity_BTree.contains(ahcheck))
			{
					bw.write(str+"\n");
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(oldTopElmt,Tag.Entity));
					allStk.push(s);
					return true;
					
			}
		}
		if(topElmt[topElmt.length-1]==1)
		{
			//System.out.println("ர் adding");
			int length=topElmt.length+1;
			byte [] oldTopElmt=new byte[length];
			for(int i=0;i<topElmt.length;i++)
			{
				oldTopElmt[i]=topElmt[i];
			}
			//System.out.println("revert="+UnicodeConverter.revert(oldTopElmt));
			oldTopElmt[topElmt.length]=25;  // 25 is internal code value of ர் 
			String str=UnicodeConverter.revert(oldTopElmt);
			//System.out.println("after added ர் revert="+UnicodeConverter.revert(oldTopElmt));
			ahcheck="";
			for(int i=0;i<oldTopElmt.length;i++)
			ahcheck+=oldTopElmt[i];
			 if(Entity_BTree.contains(ahcheck))
			{
					bw.write(str+"\n");
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(oldTopElmt,Tag.Entity));
					allStk.push(s);
					return true;
					
			}
			
		}
		if(topElmt[topElmt.length-1]==1)
		{
			//System.out.println("ம்  adding");
			int length=topElmt.length+1;
			byte [] oldTopElmt=new byte[length];
			for(int i=0;i<topElmt.length;i++)
			{
				oldTopElmt[i]=topElmt[i];
			}
			//System.out.println("revert="+UnicodeConverter.revert(oldTopElmt));
			oldTopElmt[topElmt.length]=23; //23 is internal code value of ம்
			String str=UnicodeConverter.revert(oldTopElmt);
			ahcheck="";
			for(int i=0;i<oldTopElmt.length;i++)
			ahcheck+=oldTopElmt[i];
			 if(Entity_BTree.contains(ahcheck))
			{
					bw.write(str+"\n");
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(oldTopElmt,Tag.Entity));
					allStk.push(s);
					return true;
					
			}
		}
		if(ByteMeth.endsWith(topElmt, Constant.eyya))
		{
			//System.out.println(UnicodeConverter.revert(topElmt).toString());
			String chk="";
			byte [] oldTopElmt=new byte[topElmt.length];
			for(int i=0;i<topElmt.length;i++)
			{
				oldTopElmt[i]=topElmt[i];
			}
			oldTopElmt=ByteMeth.subArray(oldTopElmt, 0,oldTopElmt.length - Constant.eyya.length);
			oldTopElmt=Sandhi.remove_kctp1(oldTopElmt);
			for(int i=0;i<oldTopElmt.length;i++)
			chk+=oldTopElmt[i];
			 if(Entity_BTree.contains(chk))
			{
					
					Stack s = (Stack) s1.clone();
					s.pop();
					s.push(new Entry(oldTopElmt,Tag.Entity));
					allStk.push(s);
					return true;
					
			}
			
		
		}
		bw.close();
	}
	catch(Exception e)
	{
		e.printStackTrace();
	}
	
		return false;
		
	}
	public static boolean adjectivalNoun(Stack allStk,byte [] topElmt)
	{
		////////System.out.println("ADictionary --- adjectivalNoun");
		Stack s = new Stack();

		s.push(new Entry(topElmt, -1));
		Sandhi.kctp(s);
		String inputstring="";
		byte[] inputByte = topElmt;
		byte[] inputByte1 = null;

		if (inputByte[inputByte.length - 1] == Constant.a[0])
		{
			inputByte1 = ByteMeth.addArray(inputByte, Constant.m);
			for(int i=0;i<inputByte1.length;i++)
			inputstring+=inputByte1[i];
			if (Noun_BTree.contains(inputstring))
			{
				//////System.out.println( "Adjectival Noun");
				s.pop();
				s.push(new Entry((inputByte), Tag.AdjectivalNoun));
				allStk.push(s);
				return true;
			}
		}
		return false;
	}
	
	public static boolean doubleNoun(Stack allStk,byte [] topElmt)
	{
		////System.out.println("ADictionary --- Double Noun called");
		Stack s = new Stack();

		s.push(new Entry(topElmt, -1));
		if(ADictionary.dnoun(s))
		{
			allStk.push(s);
			////System.out.println("I am true"+s.size());
			return true;
		}
		return false;
	}
		

	
	public static boolean noun_PronounCase_InterrogativeNoun(Stack s)
	{
		String x = "";
        	//////System.out.println("Noun/PronounCase/Interrogative Noun");
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		String input="";
		for(int i=0;i<topElmt.length;i++)
		input+=topElmt[i];

		if (Noun_BTree.contains(input))
		{
			//////System.out.println( "Noun");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Noun));
			return true;
		}
		if (BooleanMethod.isPronoun(topElmt))
		{
			//////System.out.println( "Pronoun");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Pronoun));
			return true;
		}
		if (BooleanMethod.isPronoun_Case(topElmt))
		{
			//////System.out.println( "Pronoun Case");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.PronounCase));
			return true;
		}
		if (Interrogative_BTree.contains(input))
		{
			//////System.out.println( "Interrogative Noun");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.InterrogativeNoun));
			return true;
		}
		return false;
	}

	public static boolean noun_PronounClitic_InterrogativeNoun(Stack s)
	{
		String x = "";
        	//////System.out.println("Noun/PronounClitic/Interrogative Noun");
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		String input="";
		for(int i=0;i<topElmt.length;i++)
		input+=topElmt[i];
		//////System.out.println("revert"+UnicodeConverter.revert(topElmt));
		if (Noun_BTree.contains(input))
		{
			//////System.out.println( "Noun");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Noun));
			return true;
		}
		if (BooleanMethod.isPronoun(topElmt))
		{
			//////System.out.println( "Pronoun");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Pronoun));
			return true;
		}
		if (BooleanMethod.isPronoun_Clitic(topElmt))
		{
			//////System.out.println( "Pronoun Clitic");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.PronounClitic));
			return true;
		}
		if (Interrogative_BTree.contains(input))
		{
			//////System.out.println( "Interrogative Noun");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.InterrogativeNoun));
			return true;
		}
		if(ADictionary.dnoun(s))
		return true;
		return false;
	}

	public static boolean postposition(Stack s)
	{
		String x = "";
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		String input="";
		for(int i=0;i<topElmt.length;i++)
		input+=topElmt[i];
		if (Postposition_BTree.contains(input))
		{
		
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Postposition));
			return true;
		}
		return false;
	}

	public static boolean noun(Stack s)
	{
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		String input="";
		for(int i=0;i<topElmt.length;i++)
		input+=topElmt[i];
		
		
		 if (Noun_BTree.contains(input))
		{
			
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Noun));
			return true;
		}
		else if (Entity_BTree.contains(input))
		{
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Entity));
		   	 return true;
		}
		else if (ProNoun_BTree.contains(input))
		{
			
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Pronoun));
		    return true;
		}
        	else if (En_BTree.contains(input))
		{
			if(ByteMeth.endsWith(topElmt, Constant.pathu))
			{
				
				s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Enpathu));
				return true;
			}
			else
			{
					
				    s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Enpavar));
				    return true;
			}
		}
		else  if (Particle_BTree.contains(input))
		{
			
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Particle));
			return true;
		
		}
		return false;

	}
	public static String[] sandhi_new={"14","16","18","20","22","30"};//க்,ச்,ட்,த்,ப்,ற் 
	public static String handle_double(byte[] topElmt3) //Double noun with alteration , insertion and deletion
	{
		int itr = 1;
		int numMatches = 0;
		
		Stack s=new Stack();
		// byte topElmt3[]=UnicodeConverter.convert(str);
	//ArrayList value=UnicodeConverter.getValue();
	String str=UnicodeConverter.revert(topElmt3);
	for(int i=0;i<topElmt3.length;i++){
		s.push(new Entry(topElmt3, -1));
	}
			int length =0;
			topElmt3 = ((Entry) s.peek()).getPart();
			byte[] oldTopElmt = topElmt3;
			byte[] checkElmt = topElmt3;
			String input="";
			StringBuffer output = new StringBuffer();
			String tag_str="";
			int count=0;
			List<String> tag_output = new ArrayList<String>();
			Stack s2=new Stack();
			TreeSet set=new TreeSet();
			length = topElmt3.length;
			byte[] topElmt_new=null;
			String s1="";
			byte[] remain_str;
		while(itr!=length)
	        {
			
			checkElmt= ByteMeth.subArray(topElmt3, (topElmt3.length)-itr,topElmt3.length);
			input="";
			for(int j=0;j<checkElmt.length;j++){
			input+=checkElmt[j];
						
			}
			
			       if(Noun_BTree.contains(input))
			      {
				   s.pop();
				   s.push(new Entry(checkElmt, Tag.Noun));
				   tag_str=UnicodeConverter.revert(checkElmt);				     
					tag_output.add(tag_str);
			      }
				else if (m_End_Noun_BTree.contains(input))
				{
				 tag_str=UnicodeConverter.revert(checkElmt);				     
					tag_output.add(tag_str);
				}
			    
					
				       
					
			itr++;
			
		}
			 
		
		String ip="";
		if(tag_output.size()>1){
	 
		String noun_out="";	
		noun_out=tag_output.get(tag_output.size()-1).toString();
		
		
		
			
		byte[] noun_char=UnicodeConverter.convert(noun_out);
	
		byte[] remain_char=ByteMeth.subArray(topElmt3,0,(topElmt3.length-noun_char.length));
		
		String tag=check_ending(remain_char);
		
		output.append(tag);
		output.append(noun_out+"<Noun>"+Tag.Noun);
				
		}
		else
		{
		
		
		byte[] tag_noun=UnicodeConverter.convert(tag_str);
		
		byte[] remain_char=ByteMeth.subArray(topElmt3,0,(topElmt3.length-tag_noun.length));
		
		//System.out.println("topElmt3"+topElmt3.length+"\t"+"noun_out"+tag_noun.length);


		String re=UnicodeConverter.revert(remain_char);
		//System.out.println("The remain char"+re);
		
		String tag=check_ending(remain_char);
		//System.out.println("The tag is"+tag);

			if(tag!=null){
			output.append(tag);
			output.append(tag_output.toString()+"<Noun>"+Tag.Noun);	
			}
			else
			{
			String input1="";
		for(int j=0;j<remain_char.length;j++){
			input1+=remain_char[j];
						
			}
			boolean ir_toin=false;
			if(remain_char[remain_char.length - 1 ] == 30)
			{
					oldTopElmt = remain_char.clone();
					oldTopElmt[oldTopElmt.length-1]=31; 
					
					for(int i2=0;i2<oldTopElmt.length;i2++)
						ip+=oldTopElmt[i2];
					
					tag=checknoun_string_andtag(ip,oldTopElmt);
					
					output.append(tag);
					
					output.append(tag_output.toString()+"<Noun>"+Tag.Noun);
					ir_toin=true;	
			}
			
			  else if(Non_Tamil_BTree.contains(input))
			     {
				output.append(tag_output.toString()+"<Non_Tamil>"+Tag.NonTamilNoun);
			     }
			if (Entity_BTree.contains(input))
			{
				output.append(tag_output.toString()+"<Entity>"+Tag.NonTamilNoun);
			}
			
			}//ELSE
		
		
		}
		//System.out.println("The output is"+output.toString());
		return output.toString();
	}//method end

	public static String check_ending(byte[] checkElmt)
	{
		byte[] oldTopElmt;
		byte[] sandhiElmt;
		String alter_str="";
		String input="";
		boolean sandhi_check=false;
		boolean ending_check=false;
			String input1="";
			String input2="";
			String input3="";
			String input4="";
			String input5="";
String noun_str="";
String output="";
String noun_ch;
 String sandhi_str="";
//boolean mEndnoun_check=false;


			
			String input6="";
			String input7="";
		//	System.out.println("The length of the checkElmt"+checkElmt.length);
			if(checkElmt.length != 0){
			if (ByteMeth.endsWith(checkElmt, Constant.k)
		  || ByteMeth.endsWith(checkElmt, Constant.s)
		  || ByteMeth.endsWith(checkElmt, Constant.th)
		  || ByteMeth.endsWith(checkElmt, Constant.sandhi_yi)
		  || ByteMeth.endsWith(checkElmt, Constant.p)||ByteMeth.endsWith(checkElmt, Constant.inth)||ByteMeth.endsWith(checkElmt, Constant.ing)|| ByteMeth.endsWith(checkElmt,Constant.sandhi_iCH) && !ByteMeth.endsWith(checkElmt, Constant.yng))
		{
		
		sandhiElmt = ByteMeth.subArray(checkElmt,checkElmt.length-1,checkElmt.length);
		//byte c=checkElmt[checkElmt.length-1];
		sandhi_str += sandhiElmt;
		sandhi_str=UnicodeConverter.revert(sandhiElmt);
		//System.out.println("Yes sandhi checking"+sandhi_check+sandhiElmt+sandhi_str);
		//alter_str=sandhi_str+"<sandhi>";
		sandhi_check=true;
		checkElmt= ByteMeth.subArray(checkElmt,0,checkElmt.length - Constant.k.length);
		
		
		}
		
System.out.println("before in"+UnicodeConverter.revert(checkElmt));
					if(checkElmt[checkElmt.length - 1 ] == 30)
					{
					oldTopElmt = checkElmt.clone();
					oldTopElmt[oldTopElmt.length-1]=26; 
					
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input1+=oldTopElmt[i2];
					
					alter_str=checknoun_string_andtag(input1,oldTopElmt);
					
					ending_check=true;
					
					
					}
					
					
					else if(checkElmt[checkElmt.length - 1]==22)
					{
					oldTopElmt = checkElmt.clone();
					oldTopElmt[oldTopElmt.length-1]=23; 
					
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input3+=oldTopElmt[i2];
					alter_str=checknoun_string_andtag(input3,oldTopElmt);
					//output.append(iPtoIm);
										ending_check=true;
					}
					else if(checkElmt[checkElmt.length - 1]==18)
					{
					oldTopElmt = checkElmt.clone();
					oldTopElmt[oldTopElmt.length-1]=19; 
					
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input4+=oldTopElmt[i2];

					
					alter_str=checknoun_string_andtag(input4,oldTopElmt);
					//output.append(iTtoIn);
										ending_check=true;
					}
					else if(checkElmt[checkElmt.length - 1]==24)
					{
						
					oldTopElmt = ByteMeth.subArray(checkElmt, 0,checkElmt.length-1);	
					System.out.println("Now the String is"+UnicodeConverter.revert(oldTopElmt));
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input5+=oldTopElmt[i2];
					alter_str=checknoun_string_andtag(input5,oldTopElmt);
					//output.append(yam_rmv);
					ending_check=true;
					}
					else if (ByteMeth.endsWith(checkElmt, Constant.yam))
					{
					System.out.println("YAM");
				oldTopElmt = ByteMeth.subArray(checkElmt, 0,checkElmt.length - Constant.yam.length);
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input5+=oldTopElmt[i2];
					alter_str=checknoun_string_andtag(input5,oldTopElmt);
					//output.append(yam_rmv);
									ending_check=true;
					}
					else if (ByteMeth.endsWith(checkElmt, Constant.yng))
					{
				oldTopElmt = ByteMeth.subArray(checkElmt, 0,checkElmt.length - Constant.yng.length);
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input6+=oldTopElmt[i2];
					alter_str=checknoun_string_andtag(input6,oldTopElmt);
//					output.append(yng_rmv);
										ending_check=true;
					}
					else if (ByteMeth.endsWith(checkElmt, Constant.ang))
					{
				oldTopElmt = ByteMeth.subArray(checkElmt, 0,checkElmt.length - Constant.ang.length);
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input7+=oldTopElmt[i2];
					alter_str=checknoun_string_andtag(input7,oldTopElmt);
					
										ending_check=true;
					}
					else if(ByteMeth.isEqual(checkElmt,Constant.per))
					{
					oldTopElmt = Constant.perumai;
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input7+=oldTopElmt[i2];
					System.out.println("OOR"+UnicodeConverter.revert(oldTopElmt));
					alter_str=checknoun_string_andtag(input7,oldTopElmt);
					
										ending_check=true;
					if(alter_str == null)
					{
					if (Adjective_BTree.contains(input7))
					{
					alter_str=UnicodeConverter.revert(oldTopElmt)+"<Adjective>"+Tag.Adjective;
					}
					}
					}
					else if(ByteMeth.isEqual(checkElmt,Constant.citrur))
					{
					oldTopElmt = Constant.sirumai;
					for(int i2=0;i2<oldTopElmt.length;i2++)
						input7+=oldTopElmt[i2];
					System.out.println("OOR"+UnicodeConverter.revert(oldTopElmt));
					
					alter_str=checknoun_string_andtag(input7,oldTopElmt);
					
										ending_check=true;
					if(alter_str == null)
					{
					if (Adjective_BTree.contains(input7))
					{
					alter_str=UnicodeConverter.revert(oldTopElmt)+"<Adjective>"+Tag.Adjective;
					}
					}
					}
					
					else if(ending_check==false)
					{
					for(int i2=0;i2<checkElmt.length;i2++)
						input7+=checkElmt[i2];
					String rec_noun_check=UnicodeConverter.revert(checkElmt);
					
					if(sandhi_check==true)
					{
					noun_ch=checknoun_string_andtag(input7,checkElmt);
					//System.out.println("Before m_end"+UnicodeConverter.revert(checkElmt));
					if(noun_ch == null)
					{
						if (m_End_Noun_BTree.contains(input7))
						{
						noun_ch=UnicodeConverter.revert(checkElmt)+"<m_EndNoun>";
			
						
						}
						else
						{
						noun_ch=handle_double(checkElmt);
						//System.out.println("Recursive Success"+noun_ch);
						}
					}	
				
					alter_str= alter_str+noun_ch+sandhi_str+"<sandhi>";
					}
					else
					{
					//alter_str= alter_str+handle_double(rec_noun_check);
					noun_ch=checknoun_string_andtag(input7,checkElmt);
					alter_str= alter_str+noun_ch;
					}

					}					
					

					
		}
	//System.out.println("The remaining tagged output is"+alter_str);
	return alter_str;
	}


	public static String checknoun_string_andtag(String input,byte[] TopElmt)
	{
		StringBuffer output=new StringBuffer();
		TreeSet set=new TreeSet();
		String tag_str="";
		//System.out.println("IRTOIN"+UnicodeConverter.revert(TopElmt));
		 if(Noun_BTree.contains(input))
		 {
			
				
			tag_str=UnicodeConverter.revert(TopElmt);
			//if(set.add(tag_str))
			output.append(tag_str+"<Noun>"+Tag.Noun);
			return output.toString();	
			
					
		}
		else if (m_End_Noun_BTree.contains(input))
		{
			tag_str=UnicodeConverter.revert(TopElmt);
			//if(set.add(tag_str))
			output.append(tag_str+"<AdjectivalNoun>"+Tag.AdjectivalNoun);
			return output.toString();
		}
		else if(Demo_Adj_BTree.contains(input))
		{
			tag_str=UnicodeConverter.revert(TopElmt);
			//if(set.add(tag_str))
			output.append(tag_str+"<Demo_Adj>"+Tag.DemonstrativeAdjective);
			return output.toString();
		}
		else if (Adjective_BTree.contains(input))
		{
					tag_str=UnicodeConverter.revert(TopElmt);
			//if(set.add(tag_str))
			output.append(tag_str+"<Adjective>"+Tag.Adjective);
			return output.toString();
		}
		
			return null;
	}

	public static String colloquial(Stack allStk,byte[] topElmt1) {
	//System.out.println("In Adictionary colloquial");
	String analysed="";
        try {
		//System.out.println("check for entering: "+allStk+"		"+topElmt1);
		//String sch=UnicodeConverter.revert(topElmt1);
		//System.out.println("topElmt in string "+sch);
		//System.out.println("In Adictionary colloquial inside try");
            BufferedWriter bw = new BufferedWriter(new FileWriter("./outputcollquial.txt", true));
           Stack s2 = new Stack();
            String str=UnicodeConverter.revert(topElmt1);
		//System.out.println("STR"+str);
          s2.push(new Entry(topElmt1, -1));
            //Sandhi.kctp(s2);
            allStk.push(s2);
           Stack s1 = (Stack) allStk.pop();
          byte[] topElmt = ((Entry) s1.peek()).getPart();
            String ahcheck = "";
		
           //finish //ஞ்சு convert to ய்ந்து
            /* if (ByteMeth.endsWith(topElmt, Constant.nju)) {
		//System.out.println("inside nju");
                if (topElmt[topElmt.length - 4] != 7) {
                    String value = UnicodeConverter.revert(topElmt);
                    String chk = "";
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nju.length);

                    // adding ய்ந்து after removing ஞ்சு from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.Yndhu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
			//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                } else if (topElmt[topElmt.length - 4] == 7) //செஞ்சு
                {
                    String value = UnicodeConverter.revert(topElmt);
                    String chk = "";
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nju.length);

                    // adding ய்ந்து after removing ஞ்சு from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.ydhu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
	            //System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                }    
	}
            
            //This part which explains about the "ல" ending words. (e.g) நேரத்துல, வேலைல, போகல, ஊர்ல

       if (ByteMeth.endsWith(topElmt, Constant.la)) {
                if ((topElmt[topElmt.length - 3] == 5)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);
                    if ((oldTopElmt[oldTopElmt.length - 1] == 5))//  && (topElmt[topElmt.length-2]==31))
                    {
                        oldTopElmt[oldTopElmt.length - 1] = 3;
                    }
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.l);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
		//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 9)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yil);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
		//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 1)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.villai);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
		//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 25)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 1] = 26;
                    oldTopElmt[oldTopElmt.length - 2] = 3;
                    byte[] oldElmt = new byte[oldTopElmt.length];
                    for (int i = 0; i < oldTopElmt.length; i++) {
                        oldElmt[i] = oldTopElmt[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
		//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 3)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.a.length);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
		//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 1] == 1)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 1] = 9;
                    byte[] oldElmt = new byte[oldTopElmt.length];
                    for (int i = 0; i < oldTopElmt.length; i++) {
                        oldElmt[i] = oldTopElmt[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
		//System.out.println("In analysed if condition "+analysed);
                    bw.write(value + "	" + analysed);
                }
            }*/

	//கிற  rule for colloquial
            if (ByteMeth.endsWith(topElmt, Constant.kkiRa)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kkiRa.length);

                // adding கிறாய்  after removing கிற from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kkiRai);

                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            // finish ணும் convert to வேண்டும்
            if (ByteMeth.endsWith(topElmt, Constant.Num)) {
                if ((topElmt[topElmt.length - 4] != 7) && (topElmt[topElmt.length - 5] != 27)) //except வேணும்
                {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.Num.length);

                    // adding வேண்டும்  after removing ணும் from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.vENdum);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }

            // finish ஞ்சு convert to ய்ந்து
            if (ByteMeth.endsWith(topElmt, Constant.nju)) {
                if (topElmt[topElmt.length - 4] != 7) {
                    String value = UnicodeConverter.revert(topElmt);
                    String chk = "";
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nju.length);

                    // adding ய்ந்து after removing ஞ்சு from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.Yndhu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } else if (topElmt[topElmt.length - 4] == 7) //செஞ்சு
                {
                    String value = UnicodeConverter.revert(topElmt);
                    String chk = "";
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nju.length);

                    // adding ய்ந்து after removing ஞ்சு from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.ydhu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }
	
            // not finish but thaakkaraanga not handle கறாங்க to குகிறார்கள்
            if(ByteMeth.endsWith(topElmt, Constant.kraanga)) {
                if (topElmt[topElmt.length - 8] != 14) {
                    String value = UnicodeConverter.revert(topElmt);
                    String chk = "";
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kraanga.length);



                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kukiraaragal);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } // கறாங்க to கிறார்கள்
                else if (topElmt[topElmt.length - 8] == 14) {
                    String value = UnicodeConverter.revert(topElmt);
                    String chk = "";
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kraanga.length);

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kiraaragal);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }


            // finish ப convert to பொழுது
            if(ByteMeth.endsWith(topElmt, Constant.pa)) {
                if (topElmt[topElmt.length - 3] == 22) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.pa.length);

                    // adding பொழுது  after removing ப from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.pozuthu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }

            // finish கேன் convert to கிறேன்
            if(ByteMeth.endsWith(topElmt, Constant.ken)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.ken.length);

                // adding கிறேன்  after removing கேன் from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kiren);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //finish னிக்கு convert to றைக்கு
           if(ByteMeth.endsWith(topElmt, Constant.nikku)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nikku.length);

                // adding றைக்கு  after removing னிக்கு from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.raiku);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            // finish  போ convert to பொழுது
           if(ByteMeth.endsWith(topElmt, Constant.pO)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.pO.length);

                // adding பொழுது  after removing போ from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.pozuthu);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            // finish கீங்க  convert to கிறீர்கள்
           if(ByteMeth.endsWith(topElmt, Constant.Kiinga)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.Kiinga.length);

                // adding கிறீர்கள் after removing கீங்க from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kireerkal);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            // finish கினுகிறான் convert to கொண்டிருக்கிறான்
           if(ByteMeth.endsWith(topElmt, Constant.kinukiraan)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kinukiraan.length);

                // adding கொண்டிருக்கிறான்  after removing கினுகிறான் from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kondirukiraan);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            // not finish by the ending of du டுறேன் convert to விடுகிறேன்
            if(ByteMeth.endsWith(topElmt, Constant.duren)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.duren.length);

                // adding விடுகிறேன் after removing டுறேன் from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.vidukiren);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //finish ம்புட்டு convert to வ்வளவு 
            if(ByteMeth.endsWith(topElmt, Constant.mputtu)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.mputtu.length);

                // adding வ்வளவு  after removing ம்புட்டு from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.vvalavu);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }


            // finish This method which handles if the last will be "ச்சு"

            if(ByteMeth.endsWith(topElmt, Constant.chchu)) {
                if ((topElmt[topElmt.length - 4] == 2) || (topElmt[topElmt.length - 4] == 11)) {  //போச்சு - போயிற்று or ஆச்சு - ஆயிற்று
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.chchu.length);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yitru);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 4] == 3) || (topElmt[topElmt.length - 4] == 9)) { //உபயோகிச்சு - உபயோகித்து or மறைச்சு - மறைத்து
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.chchu.length);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.ththu);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                }
            }


            //This part which explains about the ending of "து" characters.

            else if ((ByteMeth.endsWith(topElmt, Constant.thu))) {

                if ((topElmt[topElmt.length - 4] == 2) && (topElmt[topElmt.length - 3] == 20) && (topElmt[topElmt.length - 5] != 22) && (topElmt[topElmt.length - 5] != 27)) { //நாத்து - நாற்று and if பாத்து, வாத்து comes no change
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 2] = 30;
                    oldTopElmt[oldTopElmt.length - 3] = 30;
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 6] != 14) && (topElmt[topElmt.length - 5] == 17)) { //
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 3] = 1;
                    oldTopElmt[oldTopElmt.length - 4] = 20;
                    oldTopElmt[oldTopElmt.length - 5] = 21;
                    byte[] oldElmt = new byte[oldTopElmt.length];
                    for (int i = 0; i < oldTopElmt.length; i++) {
                        oldElmt[i] = oldTopElmt[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 4] == 20) && (topElmt[topElmt.length - 5] == 20) && (topElmt[topElmt.length - 7] != 14) && (topElmt[topElmt.length - 7] != 20) && (topElmt[topElmt.length - 7] != 22)) { // சுத்துது - சுற்றுது and if கத்துது, பத்துது, தத்துது comes no change
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 4] = 30;
                    oldTopElmt[oldTopElmt.length - 5] = 30;
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                }
            }

            //This part which explains about the ending of "குது"
            if(ByteMeth.endsWith(topElmt, Constant.kudhu)) //தவிக்குது - தவிக்கின்றது
            {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kudhu.length);
                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kinRathu);
                String chk = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(chk, true);
                bw.write(value + "	" + analysed);
            }

            //வேணாம் convert to வேண்டாம்
            if(ByteMeth.endsWith(topElmt, Constant.Am)) {
		String values=UnicodeConverter.revert(topElmt);
                topElmt = ByteMeth.subArray(topElmt, 0, topElmt.length - Constant.Am.length);
                if ((topElmt[topElmt.length - 1] == 19)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.t);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.Am);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(values + "	" + analysed);
                }
            }

            //This part which explains about the ending of "ன்றது"
            if(ByteMeth.endsWith(topElmt, Constant.nRathu)) //சொல்றதுன்றது  - சொல்வதென்பது
            {
                if ((topElmt[topElmt.length - 7] == 20) && (topElmt[topElmt.length - 6] == 5)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 4] = 22;
                    oldTopElmt[oldTopElmt.length - 6] = 7; // value for எ is 7
                    oldTopElmt[oldTopElmt.length - 9] = 27;
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                }
            }

            //finish This part which explains about the ending of "யினும்"
            if(ByteMeth.endsWith(topElmt, Constant.yinum)) //வேண்டுமாயினும்  - வேண்டுமானாலும்
            {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.yinum.length);
                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.naalum);
                String chk = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(chk, true);
                bw.write(value + "	" + analysed);
            }

            //யிது convert to கின்றது 
            if(ByteMeth.endsWith(topElmt, Constant.yidhu)) {
		topElmt = ByteMeth.subArray(topElmt, 0, topElmt.length - Constant.yidhu.length);
                if ((topElmt[topElmt.length - 2] != 22) || (topElmt[topElmt.length - 2] != 14)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    
		    String su = UnicodeConverter.revert(oldTopElmt);
		    System.out.println("su "+su);
                    // adding கின்றது   after removing யிது from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kinRathu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 2 ]== 22) || (topElmt[topElmt.length - 2] == 14)){ // this is for பாயிது and காயிது
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    //oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.yidhu.length);
		    String su1 = UnicodeConverter.revert(oldTopElmt);
		    System.out.println("su1 "+su1);
                    // adding கின்றது   after removing யிது from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yikinRathu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }

            //யுது convert to கின்றது 
           /* if (ByteMeth.endsWith(topElmt, Constant.yudhu)) {
                if ((topElmt[topElmt.length - 6] != 22) || (topElmt[topElmt.length - 6] != 14)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.yudhu.length);
	            String su2 = UnicodeConverter.revert(oldTopElmt);
		    System.out.println("su2 "+su2);
                    // adding கின்றது   after removing யுது from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kinRathu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 6] == 22) || (topElmt[topElmt.length - 6] == 14)){ // this is for பாயுது and காயுது
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.yudhu.length);
	 	    String su3 = UnicodeConverter.revert(oldTopElmt);
		    System.out.println("su3 "+su3);
                    // adding கின்றது   after removing யுது from input string

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yikinRathu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }*/


            //This part which explains about the ending of "ன்னு" characters.

           if(ByteMeth.endsWith(topElmt, Constant.nnu)) {
                if ((topElmt[topElmt.length - 4] == 2) || (topElmt[topElmt.length - 4] == 5)) { //வந்தாரான்னு, அழகுன்னு
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nnu.length);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.nRu);
                    oldTopElmt[oldTopElmt.length - 4] = 7; // value for எ is 7
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else { //ன்னு - ன்று
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nnu.length);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.nRu);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                }
            }
	//This is for the ending words "ளா"
	    
            if(ByteMeth.endsWith(topElmt, Constant.Laa)) {
		String values=UnicodeConverter.revert(topElmt);
		topElmt = ByteMeth.subArray(topElmt, 0, topElmt.length - Constant.Laa.length);
		if ((topElmt[topElmt.length - 1] == 8) && (topElmt[topElmt.length - 2] == 20)) { 
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.they.length);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.thIr);
		    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kaLaa);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(values + "	" + analysed);
		}
                else if ((topElmt[topElmt.length - 1] == 8) && (topElmt[topElmt.length - 2] == 18)) { //வந்தாரான்னு, அழகுன்னு
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.Day.length);
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.Teer);
	            oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kaLaa);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(values + "	" + analysed);
                } 
            }
		
            //This part which explains about the "ல" ending words. (e.g) நேரத்துல, வேலைல, போகல, ஊர்ல

           if(ByteMeth.endsWith(topElmt, Constant.la)) {
                if ((topElmt[topElmt.length - 3] == 5)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);
                    if ((oldTopElmt[oldTopElmt.length - 1] == 5))//  && (topElmt[topElmt.length-2]==31))
                    {
                        oldTopElmt[oldTopElmt.length - 1] = 3;
                    }
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.l);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 9)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yil);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 1)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);

                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.villai);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 25)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt[oldTopElmt.length - 1] = 26;
                    oldTopElmt[oldTopElmt.length - 2] = 3;
                    byte[] oldElmt = new byte[oldTopElmt.length];
                    for (int i = 0; i < oldTopElmt.length; i++) {
                        oldElmt[i] = oldTopElmt[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 3] == 3)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.a.length);
                    String chk = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else if ((topElmt[topElmt.length - 1] == 1)) {
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];

                    }
                    oldTopElmt[oldTopElmt.length - 1] = 9;
                    byte[] oldElmt = new byte[oldTopElmt.length];
                    for (int i = 0; i < oldTopElmt.length; i++) {
                        oldElmt[i] = oldTopElmt[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }

            //This part which explains about the "கிறது" ending words.

            else if ((ByteMeth.endsWith(topElmt, Constant.kiRathu))) {
                String value = UnicodeConverter.revert(topElmt); //சுத்துகிறது - சுற்றுகின்றது
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kiRathu.length);
                if ((oldTopElmt[oldTopElmt.length - 2] == 20) && (oldTopElmt[oldTopElmt.length - 3] == 20) && (oldTopElmt[oldTopElmt.length - 5] != 14) && (oldTopElmt[oldTopElmt.length - 5] != 20) && (oldTopElmt[oldTopElmt.length - 5] != 22)) { // சுத்துது - சுற்றுது and if கத்துது, பத்துது, தத்துது comes no change
                    String values = UnicodeConverter.revert(oldTopElmt);
                    byte[] topElmts = new byte[oldTopElmt.length];
                    for (int i = 0; i < oldTopElmt.length; i++) {
                        topElmts[i] = oldTopElmt[i];
                    }
                    topElmts[topElmts.length - 2] = 30;
                    topElmts[topElmts.length - 3] = 30;
                    topElmts = ByteMeth.addArray(topElmts, Constant.kinRathu);
                    String chk = UnicodeConverter.revert(topElmts);
                    analysed = Analyser.analyseF(chk, true);
                    bw.write(value + "	" + analysed);
                } else { //சுற்றுகிறது - சுற்றுகின்றது
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kinRathu);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }
            }

            //This part which explains about the "ன்னா" ending words.

            if(ByteMeth.endsWith(topElmt, Constant.nnaa)) {
                if ((topElmt[topElmt.length - 6] != 26) && (topElmt[topElmt.length - 7] != 3)) { // if not வரவில்லைன்னா and இல்லைன்னா
                    String value = UnicodeConverter.revert(topElmt);
                    byte[] oldTopElmt = new byte[topElmt.length];
                    for (int i = 0; i < topElmt.length; i++) {
                        oldTopElmt[i] = topElmt[i];
                    }
                    oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.nnaa.length);

                    if ((oldTopElmt[oldTopElmt.length - 1] == 1) || (oldTopElmt[oldTopElmt.length - 1] == 9) && ((oldTopElmt[oldTopElmt.length - 6] != 3) && (oldTopElmt[oldTopElmt.length - 2] != 3) && (oldTopElmt[oldTopElmt.length - 3] != 26))) { // வரலன்னா - வரவில்லையென்றால்
                        oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.la.length);
                        oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.villai);
                    }
                    oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yenRaal);
                    String s = UnicodeConverter.revert(oldTopElmt);
                    //System.out.println(s);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                } else { //வரவில்லைன்னா - - வரவில்லையென்றால்
                    String value = UnicodeConverter.revert(topElmt);
                    topElmt = ByteMeth.subArray(topElmt, 0, topElmt.length - Constant.nnaa.length);
                    topElmt = ByteMeth.addArray(topElmt, Constant.yenRaal);
                    String s = UnicodeConverter.revert(topElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(value + "	" + analysed);
                }

            }


            // finsh துச்சி convert to தது
            if(ByteMeth.endsWith(topElmt, Constant.thuchchi)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.thuchchi.length);

                // adding தது  after removing துச்சி from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.thathu);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            if(ByteMeth.endsWith(topElmt, Constant.su)) {
                String values = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.su.length);

                // adding ரியது  after removing ருசு from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yathu);
                byte[] check = new byte[oldTopElmt.length];
                for (int i = 0; i < oldTopElmt.length; i++) {
                    check[i] = oldTopElmt[i];
                }

                if ((check[check.length - 5] == 1) && (check[check.length - 6] == 28))//
                {
                    String valuee = UnicodeConverter.revert(check);
                    byte[] oldTopElmtee = check.clone();
                    oldTopElmtee[oldTopElmtee.length - 5] = 9;
                    byte[] oldElmt = new byte[oldTopElmtee.length];
                    for (int i = 0; i < oldTopElmtee.length; i++) {
                        oldElmt[i] = oldTopElmtee[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(values + "	" + analysed);
                } else if ((check[check.length - 5] == 5) && ((check[check.length - 6] == 20) || (check[check.length - 6] == 25) || (check[check.length - 6] == 30))) {
                    String valued = UnicodeConverter.revert(check);
                    byte[] oldTopElmte = check.clone();
                    oldTopElmte[oldTopElmte.length - 5] = 3;
                    byte[] oldElmt = new byte[oldTopElmte.length];
                    for (int i = 0; i < oldTopElmte.length; i++) {
                        oldElmt[i] = oldTopElmte[i];
                    }
                    String s = UnicodeConverter.revert(oldElmt);
                    analysed = Analyser.analyseF(s, true);
                    bw.write(values + "	" + analysed);
                }

            }


            // finish கிட்ட convert to ளிடம்
            if(ByteMeth.endsWith(topElmt, Constant.kitta)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];

                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kitta.length);

                // adding ளிடம்  after removing கிட்ட from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.lidam);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //யோட convert to யுடன்
            if(ByteMeth.endsWith(topElmt, Constant.yoda)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.yoda.length);

                // adding ளிடம்  after removing கிட்ட from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.yudan);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //களா convert to வருந்தினாங்களா
            if(ByteMeth.endsWith(topElmt, Constant.kaLaa) && (topElmt[topElmt.length - 5] == 15)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 5] = 25;
                byte[] oldElmt = new byte[oldTopElmt.length];
                for (int i = 0; i < oldTopElmt.length; i++) {
                    oldElmt[i] = oldTopElmt[i];
                }
                String s = UnicodeConverter.revert(oldElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            /*கேக்க to கேட்க
            if ((topElmt[topElmt.length - 3] == 14) && (topElmt[topElmt.length - 4] == 8)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 3] = 18;

                byte[] oldElmt = new byte[oldTopElmt.length];
                for (int i = 0; i < oldTopElmt.length; i++) {
                    oldElmt[i] = oldTopElmt[i];
                }
                String s = UnicodeConverter.revert(oldElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }*/

            //முடிஞ்சுது to முடிந்தது
           else if ((ByteMeth.endsWith(topElmt, Constant.thu)) && (topElmt[topElmt.length - 3] == 5)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 3] = 1;
                oldTopElmt[oldTopElmt.length - 4] = 20;
                oldTopElmt[oldTopElmt.length - 5] = 21;
                byte[] oldElmt = new byte[oldTopElmt.length];
                for (int i = 0; i < oldTopElmt.length; i++) {
                    oldElmt[i] = oldTopElmt[i];
                }
                String s = UnicodeConverter.revert(oldElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //கறா convert to கிறாள்
            if(ByteMeth.endsWith(topElmt, Constant.kaRaa)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kaRaa.length);

                // adding கிறாள்  after removing கறா from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kiRaal);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }


            //ல்லுச்சி convert to ன்னது
            if(ByteMeth.endsWith(topElmt, Constant.lluchchi)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.lluchchi.length);

                // adding ன்னது  after removing ல்லுச்சி from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.nnadhu);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //குங்க convert to க்கொள்
            if(ByteMeth.endsWith(topElmt, Constant.kunga)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                oldTopElmt = ByteMeth.subArray(oldTopElmt, 0, oldTopElmt.length - Constant.kunga.length);

                // adding க்கொள்  after removing குங்க from input string

                oldTopElmt = ByteMeth.addArray(oldTopElmt, Constant.kkol);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //கம்மியா convert to குறைவாக (changing word itself)
            if(ByteMeth.contains(topElmt, Constant.kammiya)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = new byte[topElmt.length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }

                // adding குறைவாக after removing கம்மியா from input string
                byte[] Elmt = new byte[oldTopElmt.length - Constant.kammiya.length];
                oldTopElmt = ByteMeth.addArray(Elmt, Constant.kuraivaga);
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            //வு convert to யி (e.g) கவுறு convert to கயிறு
	if(ByteMeth.endsWith(topElmt, Constant.Ru)) {
           if ((topElmt[topElmt.length - 3] == 5) && (topElmt[topElmt.length - 4] == 27)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 3] = 3;
                oldTopElmt[oldTopElmt.length - 4] = 24;
                byte[] oldElmt = new byte[oldTopElmt.length];
                for (int i = 0; i < oldTopElmt.length; i++) {
                    oldElmt[i] = oldTopElmt[i];
                }
                String s = UnicodeConverter.revert(oldElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }
	}

            //ல convert to லை (e.g)தொலவு convert to தொலைவு
            if ((topElmt[topElmt.length - 3] == 1) && (topElmt[topElmt.length - 4] == 26)) {
                String value = UnicodeConverter.revert(topElmt);
                byte[] oldTopElmt = topElmt.clone();
                oldTopElmt[oldTopElmt.length - 3] = 9;
                byte[] oldElmt = new byte[oldTopElmt.length];
                for (int i = 0; i < oldTopElmt.length; i++) {

                    oldElmt[i] = oldTopElmt[i];
                }
                String s = UnicodeConverter.revert(oldElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

            if ((topElmt[topElmt.length - 1] == 2) && (topElmt[topElmt.length - 2] == 20)) {
                String value = UnicodeConverter.revert(topElmt);
                //System.out.println("ன்  adding");
                int length = topElmt.length + 1;
                byte[] oldTopElmt = new byte[length];
                for (int i = 0; i < topElmt.length; i++) {
                    oldTopElmt[i] = topElmt[i];
                }
                ////System.out.println("revert="+UnicodeConverter.revert(oldTopElmt));
                oldTopElmt[topElmt.length] = 26; //26 is internalcode value of ல்
                //oldTopElmt[topElmt.length]=29;
                String s = UnicodeConverter.revert(oldTopElmt);
                analysed = Analyser.analyseF(s, true);
                bw.write(value + "	" + analysed);
            }

          
            bw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
	//System.out.println("analysed output "+analysed);
        return analysed;
    }



	//double noun

	public static boolean dnoun(Stack s)
	{
			int i = 1;
			int length =0;
			byte[] topElmt = ((Entry) s.peek()).getPart();
			byte[] oldTopElmt = topElmt;
			byte[] checkElmt = topElmt;
			String input="";
			
		length = topElmt.length;
		while(i!=length)
	        {
			
			checkElmt= ByteMeth.subArray(topElmt, (topElmt.length)-i,topElmt.length);
			input="";
			for(int j=0;j<checkElmt.length;j++)
			input+=checkElmt[j];
			
			      if (Noun_BTree.contains(input))
			      {
				       s.pop();
				       s.push(new Entry(checkElmt, Tag.Noun));
					//////System.out.println("break");
				       break;
			      }
			      else if (Adjective_BTree.contains(input))
				{
					////////System.out.println("ADJ");
					//////System.out.println( "ADJ");
					//Stack s = (Stack) s1.clone();

					s.pop();
					s.push(new Entry(checkElmt, Tag.Adjective));
					 break;

				}				
		          i++;
		}

		
		    if(i!=length)
		    {  
				checkElmt= ByteMeth.subArray(topElmt,0, topElmt.length-i);
				s.push(new Entry(checkElmt, -1, oldTopElmt));
				Sandhi.kctp(s);
				//Sandhi.kctp(s);
				checkElmt = ((Entry) s.peek()).getPart();
				input="";
				////System.out.println("check Element         "+UnicodeConverter.revert(checkElmt));
			 	for(int i1=0;i1<checkElmt.length;i1++)
				input+=checkElmt[i1];
			    	if (Noun_BTree.contains(input))
				{
						//////System.out.println( "Noun");
						s.pop();
						s.push(new Entry(checkElmt, Tag.Noun));
						return true;
				}
				if (m_End_Noun_BTree.contains(input))
				{
						//////System.out.println( "Noun");
						s.pop();
						s.push(new Entry(checkElmt, Tag.AdjectivalNoun));
						return true;
				}
			}
					//////System.out.println(" after while");
			     return false;

	}
	        public static boolean m_EndNoun(Stack s)
		{
			byte[] topElmt = ((Entry) s.peek()).getPart();
			byte[] oldTopElmt = topElmt;
			String input="";
			for(int i=0;i<topElmt.length;i++)
			input+=topElmt[i];
			if(ByteMeth.endsWith(topElmt, Constant.u))
		    {
			  topElmt = ByteMeth.subArray(topElmt, 0,
			  topElmt.length - Constant.u.length);
			  topElmt = ByteMeth.addArray(topElmt, Constant.a);
		    }

			if (m_End_Noun_BTree.contains(input))
			{
				//////System.out.println( "AdjectivalNoun");
				s.push(new Entry(((Entry) s.pop()).getPart(), Tag.AdjectivalNoun));
				return true;
			}
			return false;
	    }

	// Adverb
	public static boolean adverb(Stack s)
	{
		Sandhi.kctp(s);		//this statement is for checking whether the adverb comes with sandhi or not
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		String input="";
		for(int i=0;i<topElmt.length;i++)
		input+=topElmt[i];

		if (Adverb_BTree.contains(input))
		{
			//////System.out.println( "Adverb");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Adverb));
			return true;
		}
		return false;
	}

	// Verb
	public static boolean verb(Stack s)
	{
		//////System.out.println( "Chking Verb Dic");
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		String input="";
		for(int i=0;i<topElmt.length;i++)
		input+=topElmt[i];

		//////System.out.println("revert  1 "+UnicodeConverter.revert(topElmt));
		if (Verb_BTree.contains(input))
		{
			//////System.out.println("Verb_BTree True");
			if(ByteMeth.isEqual(topElmt, Constant.en))
			{
				//////System.out.println( "En");
				s.push(new Entry(((Entry) s.pop()).getPart(), Tag.En));
			    return true;
			}
			else
			{
			//////System.out.println( "Verb");
			s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Verb));
			return true;
		    }
		}
		return false;
	}

	//Nverb 1-06-06
  public static boolean Nverb(Stack s)
  	{
		int i = 1;
		int length =0;
		//////System.out.println( "Chking Noun+Verb Dic");
  		byte[] topElmt = ((Entry) s.peek()).getPart();
  		byte[] oldTopElmt = topElmt;
		String input="";

        byte[] checkElmt = topElmt;
        length = topElmt.length;
        while(i!=length)
			  {
			  checkElmt= ByteMeth.subArray(topElmt, (topElmt.length)-i,
			  topElmt.length);
				input="";
			  for(int i1=0;i1< checkElmt.length;i1++)
				input+= checkElmt[i1];	
			  //////System.out.println("check Element         "+UnicodeConverter.revert(checkElmt));
  		      if (Verb_BTree.contains(input))
  	          	{
				////////System.out.println("Chking Verb Dic----mine"+checkElmt);
  	    			//////System.out.println( "Verb");
				s.pop();
				s.push(new Entry(checkElmt, Tag.Verb));
				break;
  		        }
  		        i++;
	          }
		//////System.out.println("i"+":"+i+"="+length);
	    	 if(i!=length)
		      {
			//////System.out.println("noun/verb chenking");
			  checkElmt= ByteMeth.subArray(topElmt,0, topElmt.length-i);
				input="";
			  for(int i1=0;i1< checkElmt.length;i1++)
				input+= checkElmt[i1];	
			 // //////System.out.println("Chking Verb Dic--aaaaa--mine"+checkElmt);
			 //////System.out.println("check Element         "+UnicodeConverter.revert(checkElmt));
			  s.push(new Entry(checkElmt, -1, oldTopElmt));
			Sandhi.kctp(s);
			  //Sandhi.check(s);
			 Case.check(s,true);
			  ////////System.out.println("check Element         "+UnicodeConverter.revert(checkElmt));
			  checkElmt = ((Entry) s.peek()).getPart();
			  if (Noun_BTree.contains(input))
			  		{
					//////System.out.println( "Noun");
			  		s.pop();
			  		s.push(new Entry(checkElmt, Tag.Noun));
			  		return true;
				    }
			   else
			        s.push(new Entry(checkElmt, -1));
			   }
	    //////System.out.println("return false--mine"+checkElmt);
  		return false;
	}
	public static boolean longVowel(Stack s)
	{
		byte[] topElmt = ((Entry) s.peek()).getPart();
		byte[] oldTopElmt = topElmt;
		if(topElmt[topElmt.length-1]==1)
		{

			topElmt[topElmt.length-1]=2;
			String input="";
			for(int i=0;i<topElmt.length;i++)
			input+=topElmt[i];
		//	////System.out.println("revert "+UnicodeConverter.revert(topElmt));
		
			/* if (Noun_BTree.contains(input))
			{
				//////System.out.println( "Noun");
				s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Noun));
				return true;
			}*/
			if (Entity_BTree.contains(input))
			{
				//////System.out.println("Entity");
				//clia.unl.unicode.utils.Utils.printOut(Analyser.print, x + "Entity");
				s.push(new Entry(((Entry) s.pop()).getPart(), Tag.Entity));
			   	 return true;
			}
			return false;
		}
		return false;
	}
	/*public static boolean Verbalnoun(Stack allStk,String inputString)

	{
		Stack s = new Stack();

		s.push(new Entry(TC.convert(inputString), -1));
		//Sandhi.kctp(s);

		//byte[] inputByte = ((Entry) s.peek()).getPart();
		//byte[] inputByte1 = null;

		int i = 1;
		int length =0;
		int length1=0;
		//////System.out.println( "checking verb noun");
  		byte[] topElmt = ((Entry) s.peek()).getPart();
  		byte[] oldTopElmt = topElmt;
        	byte[] checkElmt = topElmt;
        	length = topElmt.length;
		length1=inputString.length();
		boolean isNoun=false;
		boolean isVerb=false;
		Stack nounStk=new Stack();
        	while(i!=length)
			  {
			 checkElmt= ByteMeth.subArray(topElmt, (topElmt.length)-i,
			  topElmt.length);
			String input=new String(UnicodeConverter.revert(checkElmt));
			// //////System.out.println("verbalnoun        "+UnicodeConverter.revert(checkElmt));
			//for(int k=0;k< checkElmt.length;k++)		
			 //input+=checkElmt[k];
			
			//////System.out.println("input is.."+input);
			isNoun= Noun.check(allStk, input, true);
  		      if (isNoun)
  	          	{
				for(int k=0;k<allStk.size();k++)
				{
					nounStk= (Stack) allStk.get(k);
				}
				allStk.clear();
				//////System.out.println("break.."+input);
				//s.pop();
				//s.push(new Entry(checkElmt, Tag.Verb));
				break;
  		        }
  		        i++;
	          }
		if(i!=length)
		{
			checkElmt= ByteMeth.subArray(topElmt, 0,
			 (topElmt.length)-i);
			String input=new String(UnicodeConverter.revert(checkElmt));
			//s.push(new Entry(checkElmt, -1, oldTopElmt));
			//////System.out.println("verbalnoun String is "+input);
			isVerb = Verb.check(allStk, input, false);
			int size=allStk.size();
			//////System.out.println("size is "+size);
			if(isVerb)
			{
				
				allStk.push(nounStk);
				
				//s.pop();
			  	//s.push(new Entry(checkElmt, Tag.Noun));
			  	return true;
			}
		}
		return false;
	}*/
	
	/*public static boolean longvowel(Stack allStk, byte [] topElmt,boolean analysePart)
	{
		int length=topElmt.length;
		byte b=topElmt[length-1];
		if(b==1)
		{
			////System.out.println("i am AH");
		}
		return true;
	}*/
}
k, input, false);
			int size=allStk.size();
			//////System.out.println("size is "+size);
			if(isVerb)
			{
				
				allStk.push(nounStk);
				
				//s.pop();
			  	//s.push(new Entry(checkElmt, Tag.Noun));
			  	return true;
			}
		}
		return false;
	}*/
	
	/*public static boolean longvowel(Stack allStk, byte [] topElmt,boolean analysePart)
	{
		int length=topE
t.length;
		byte b=topEl
